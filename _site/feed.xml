<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-09-09T23:50:04-05:00</updated><id>http://localhost:4000/</id><entry><title type="html">Adidas Shoe Bot</title><link href="http://localhost:4000/2017/08/22/shoe-bot.html" rel="alternate" type="text/html" title="Adidas Shoe Bot" /><published>2017-08-22T00:00:00-05:00</published><updated>2017-08-22T00:00:00-05:00</updated><id>http://localhost:4000/2017/08/22/shoe-bot</id><content type="html" xml:base="http://localhost:4000/2017/08/22/shoe-bot.html">&lt;p&gt;This is a simple program that I wrote to buy shoes that are in high demand. The program uses a python selenium library to fully automate the purchasing of shoes on the adidas website, with the goal being to buy yeezys when they are first released. Yeezys have a high resale value, however they sell out in seconds so the only way to purchase them is to use a bot like this one. My bot uses a user generation script from the &lt;a href=&quot;https://github.com/kfichter/OpenATC&quot;&gt;OpenATC&lt;/a&gt; project. The user generation script allows a user to enter their personal information for the program to use. Initially I was going to try to hide the bot’s continuous requests using a tor proxy, however the adidas site was able to quickly detect the proxy and block me from accessing it. Additionally, I discovered that the yeezy purchase page requires a captha to be solved, which this program is currently unable to do.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/rmAq8mmlKnQ&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><summary type="html">This is a simple program that I wrote to buy shoes that are in high demand. The program uses a python selenium library to fully automate the purchasing of shoes on the adidas website, with the goal being to buy yeezys when they are first released. Yeezys have a high resale value, however they sell out in seconds so the only way to purchase them is to use a bot like this one. My bot uses a user generation script from the OpenATC project. The user generation script allows a user to enter their personal information for the program to use. Initially I was going to try to hide the bot’s continuous requests using a tor proxy, however the adidas site was able to quickly detect the proxy and block me from accessing it. Additionally, I discovered that the yeezy purchase page requires a captha to be solved, which this program is currently unable to do.</summary></entry><entry><title type="html">Working Autonomous Power Wheels Car</title><link href="http://localhost:4000/2017/08/08/finished-car.html" rel="alternate" type="text/html" title="Working Autonomous Power Wheels Car" /><published>2017-08-08T00:00:00-05:00</published><updated>2017-08-08T00:00:00-05:00</updated><id>http://localhost:4000/2017/08/08/finished-car</id><content type="html" xml:base="http://localhost:4000/2017/08/08/finished-car.html">&lt;p&gt;This video is of one of the most successful tests we have had of the car. In this program we used several new features we have developed since the last post I made. Most importantly, this program uses a proportional algorithm to control the steering of the robot. One of the only problems we had with the proportional algorithm was the tuning of the proportional constant as it was difficult to quickly change this value. We were able to solve this problem by developing a second version of our control software. Our new control system is based around the Node.js system and allows us to control the car though a webpage. This webpage has sliders for quickly adjusting important variables in the software, and allows us to see live updates of the results of these changes. The scanse lidar manufacturers had also written a Node oriented library that allowed us to quickly port our python algorithms into full javascript.&lt;/p&gt;

&lt;p&gt;Another important change we made was the way the car detected walls. We found that pointing the sensor at the ground allowed us to find gaps when the wall was not there. We then averaged the size of the gap to find where the car should go. When the car drove up to a wall, the gap would dissapear on one side causing the average to shift and the car to follow the shifted gap, avoiding the wall. Rather than trying to just avoid walls as our previous algorithm had done, we now follow gaps that the lidar detects, allowing the car to react and adjust more quickly.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/LcIeDqVdJx8&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><summary type="html">This video is of one of the most successful tests we have had of the car. In this program we used several new features we have developed since the last post I made. Most importantly, this program uses a proportional algorithm to control the steering of the robot. One of the only problems we had with the proportional algorithm was the tuning of the proportional constant as it was difficult to quickly change this value. We were able to solve this problem by developing a second version of our control software. Our new control system is based around the Node.js system and allows us to control the car though a webpage. This webpage has sliders for quickly adjusting important variables in the software, and allows us to see live updates of the results of these changes. The scanse lidar manufacturers had also written a Node oriented library that allowed us to quickly port our python algorithms into full javascript.</summary></entry><entry><title type="html">Two State Autonomous Power Wheels Car</title><link href="http://localhost:4000/2017/07/27/two-state-car.html" rel="alternate" type="text/html" title="Two State Autonomous Power Wheels Car" /><published>2017-07-27T00:00:00-05:00</published><updated>2017-07-27T00:00:00-05:00</updated><id>http://localhost:4000/2017/07/27/two-state-car</id><content type="html" xml:base="http://localhost:4000/2017/07/27/two-state-car.html">&lt;p&gt;In this video we used an extremely basic two state program to follow a cardboard wall. This program checks the distance value of each data point that comes in from the lidar sensor. It then turns left or right based on where the majority of the points are. The program also uses a filter to throw out all of the readings that are on the right side of the car.&lt;/p&gt;

&lt;p&gt;At present the car’s throttle is controlled using a remote, however all the steering is done autonomously through an arduino. The arduino has been programmed to accept serial communication values for steering. The python program then sends serial commands based on the lidar sensor readings. One of the most glaring problems with this program in its current state is that it has had trouble with correcting at the proper rate. This is what caused the car to crash into the back cardboard wall at the end, as the car is unable to perform tight turns. In the future we will try to implement a PID algorithm to control the car’s movements.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/6O3Oha024Ik&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><summary type="html">In this video we used an extremely basic two state program to follow a cardboard wall. This program checks the distance value of each data point that comes in from the lidar sensor. It then turns left or right based on where the majority of the points are. The program also uses a filter to throw out all of the readings that are on the right side of the car.</summary></entry><entry><title type="html">Python Sweep Visualizer</title><link href="http://localhost:4000/2017/06/10/python-sweep-vizualiser.html" rel="alternate" type="text/html" title="Python Sweep Visualizer" /><published>2017-06-10T00:00:00-05:00</published><updated>2017-06-10T00:00:00-05:00</updated><id>http://localhost:4000/2017/06/10/python-sweep-vizualiser</id><content type="html" xml:base="http://localhost:4000/2017/06/10/python-sweep-vizualiser.html">&lt;p&gt;For this program I was trying to duplicate the visualization code for the &lt;a href=&quot;http://scanse.io&quot;&gt;scanse sweep sensor&lt;/a&gt;. The scanse website has a free visualization program that displays all of the objects the sensor detects as points on a screen. In order to better understand the sensor, I set out to clone this program using the sensor’s python library. My program uses the pygame library to display all the points the sensor sees on a raspberry pi monitor. It uses several arrays to take readings from the sensor and then store those readings to be drawn on the screen. Below is a comparison of the visualizer program that is written by the manufacturer, and the visualizer that I wrote.  The python visualizer is on the left, and the visualizer written by the manufacturer is on the right.  You can look at the program on my github at the link &lt;a href=&quot;https://github.com/theshoe1029/Power-Wheels-Team/blob/86703ed78bdb096a5fb02323ce03b14120ba3899/Python/SweepVisualizer.py&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">For this program I was trying to duplicate the visualization code for the scanse sweep sensor. The scanse website has a free visualization program that displays all of the objects the sensor detects as points on a screen. In order to better understand the sensor, I set out to clone this program using the sensor’s python library. My program uses the pygame library to display all the points the sensor sees on a raspberry pi monitor. It uses several arrays to take readings from the sensor and then store those readings to be drawn on the screen. Below is a comparison of the visualizer program that is written by the manufacturer, and the visualizer that I wrote. The python visualizer is on the left, and the visualizer written by the manufacturer is on the right. You can look at the program on my github at the link here</summary></entry></feed>